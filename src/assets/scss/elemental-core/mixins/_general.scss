////
/// General style patterns
///
/// @group core
////

/// Force the bottom edge of an element to clear all of its conents.
@mixin clearfix {
  &::before,
  &::after {
    content: '\00a0';
    display: table;
  }

  &::after {
    clear: both;
  }
}

/// Hide an element.
@mixin hidden {
  display: none;
}

/// Show only in screen readers.
@mixin visually-hidden {
  // scss-lint:disable ImportantRule
  // This is an acceptable use of !important.
  position: absolute !important;
  clip: rect(1px, 1px, 1px, 1px);
  overflow: hidden;
  height: 1px;
  width: 1px;
  word-wrap: normal;
}

/// Generate focusable element styles.
@mixin focusable {
  &:active,
  &:focus {
    clip: auto;
    height: auto;
    overflow: visible;
    // scss-lint:disable ImportantRule
    // This is an acceptable use of !important.
    position: static !important;
    width: auto;
  }
}

/// Generate invisible element styles
@mixin invisible {
  visibility: hidden;
}

/// Generate link styles
///
/// @param {Color | Map} $link [$link-color]
///   Can use an individual color or a map of color keyed with state names.
@mixin link-color($link: $link-color) {
  $type: type-of($link);

  @if $type == color {
    &,
    &:visited,
    &:focus,
    &:active,
    &.active,
    .active > &,
    &:hover {
      color: $link;
    }
  } @else if $type == map {
    $default: map-get($link, default);
    $visited: map-get($link, visited);
    $hover: map-get($link, hover);
    $active: map-get($link, active);

    @if $default and length($link) == 1 {
      &,
      &:visited,
      &:focus,
      &:active,
      &.active,
      .active > &,
      &:hover {
        color: $default;
      }
    } @else {
      color: $default;

      @if $visited {
        &:visited {
          color: $visited;
        }
      }
      @if $hover and $active == null {
        &:hover,
        &:focus,
        &:active,
        &.active,
        .active > & {
          color: $hover;
        }
      } @else if $hover {
        &:hover {
          color: $hover;
        }
      }
      @if $active {
        &:focus,
        &:active,
        &.active,
        .active > & {
          color: $active;
        }
      }
    }
  }
}

/// Apply the rhythm-test class to an element to see how the basline of fonts
/// is lining up.
@mixin rhythm-test {
  background-image: repeating-linear-gradient(
      to bottom,
      transparent 0,
      transparent ($rhythm-unit - $border-width-base - .001rem),
      $color-brand_primary-3 rem-whole-pixel($rhythm-unit - $border-width-base),
      $color-brand_primary-3 $rhythm-unit
  );
}

/// Generate placeholders for common elements.
@mixin generate-placeholders {
  @if global-variable-exists(placeholders-exist) == false {
    /// Force the bottom edge of an element to clear all of its conents. (This
    /// is an implementation of the `clearfix()` mixin.)
    %clearfix {
      @include clearfix;
    }

    /// Hide an element. (This is an implementation of the ```hidden()```
    /// mixin.)
    %hidden {
      @include hidden;
    }

    /// Show only in screen readers. (This is an implementation of the
    /// `visually-hidden()` mixin.)
    %visually-hidden {
      @include visually-hidden;
    }

    /// Generate focusable element styles. (This is an implementation of the
    /// `focusable()` mixin.)
    %focusable {
      @include focusable;
    }

    /// Generate invisible element styles. (This is an implementation of the
    /// `invisible()` mixin.)
    %invisible {
      @include invisible;
    }

    %link-color {
      @include link-color;
    }

    %link-color-reverse {
      @include link-color($link-color-reverse);
    }

    // Set the global variable so that placholders are not placed multiple
    // times.
    $placeholders-exist: true !global;
  }
}
