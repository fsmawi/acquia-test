; This is the test factory configuration.

Acquia.Wip.IncludeFileInterface => Acquia\Wip\Implementation\BasicIncludeFile

; this is a comment

Acquia.Wip.StateTableParser => Acquia\Wip\Iterators\BasicIterator\BasicStateTableParser ; We should never need this one.

; another comment

acquia.wip.iterator => Acquia\Wip\Iterators\BasicIterator\StateTableIterator

acquia.wip.ssh.client => \Acquia\Wip\Ssh\Ssh

acquia.wip.phpunit.testobject => Acquia\Wip\Test\PublicStable\Resource\TestObject

$acquia.wip.test.teststring => TEST STRING

; Now, what I'm hoping is that it's ok to use a relative path in tests, and then
; use an absolute path for the actual key.
$acquia.wip.service.private_key_path => tests/Acquia/Wip/Test/PrivateStable/Runtime/Resource/testKey
$acquia.wip.service.username => testuser

acquia.wip.threadpool => \Acquia\Wip\Runtime\ThreadPool singleton
acquia.wip.lock.global => \Acquia\WipIntegrations\DoctrineORM\MySqlLockSingle singleton

acquia.wip.storage.wip => \Acquia\WipIntegrations\DoctrineORM\WipStore singleton
acquia.wip.storage.module => \Acquia\WipIntegrations\DoctrineORM\WipModuleStore singleton
acquia.wip.storage.module_task => \Acquia\WipIntegrations\DoctrineORM\WipModuleTaskStore singleton
acquia.wip.storage.thread => \Acquia\WipIntegrations\DoctrineORM\ThreadStore singleton
acquia.wip.storage.server => \Acquia\WipIntegrations\DoctrineORM\ServerStore singleton
acquia.wip.storage.state => \Acquia\WipIntegrations\DoctrineORM\StateStore singleton
acquia.wip.storage.configuration => \Acquia\WipIntegrations\DoctrineORM\ConfigurationStore singleton
acquia.wip.storage.signal => \Acquia\WipIntegrations\DoctrineORM\SignalStore singleton
acquia.wip.storage.task_definition => \Acquia\WipIntegrations\DoctrineORM\TaskDefinitionStore singleton
acquia.wip.lock.rowlock => \Acquia\WipIntegrations\DoctrineORM\MySqlLockSingle singleton
acquia.wip.lock.rowlock.wippool => \Acquia\Wip\Lock\WipPoolRowLock singleton
; A singleton is rarely a good option for unit testing.
acquia.wip.storage.wippool => \Acquia\WipIntegrations\DoctrineORM\WipPoolStore singleton
; acquia.wip.storage.wippool => \Acquia\WipIntegrations\DoctrineORM\WipPoolStore
acquia.wip.storage.ecs_cluster => \Acquia\WipIntegrations\DoctrineORM\EcsClusterStore singleton
acquia.wip.pool => \Acquia\Wip\Runtime\WipPool
acquia.wip.wiplog => \Acquia\Wip\Implementation\WipLog
acquia.wip.wiplogstore => \Acquia\WipIntegrations\DoctrineORM\WipLogStore singleton
; acquia.wip.wiplogstore => \Acquia\WipIntegrations\DoctrineORM\WipFlushingContainerLogStore
acquia.wip.api => \Acquia\Wip\Implementation\WipTaskApi
acquia.wip.ssh => \Acquia\Wip\Implementation\SshApi
acquia.wip.ssh_service => \Acquia\Wip\Ssh\SshService
acquia.wip.ssh_service.local => \Acquia\Wip\Ssh\LocalExecSshService
acquia.wip.acquiacloud => \Acquia\Wip\Implementation\AcquiaCloudApi
acquia.wip.acquiacloud.api => Acquia\Wip\AcquiaCloud\AcquiaCloud
acquia.wip.application => \Acquia\Wip\Runtime\WipApplication
acquia.wip.handler.signal => \Acquia\WipService\Utility\SignalCallbackHttpTransport singleton
acquia.wip.handler.containers => \Acquia\WipIntegrations\Container\DockerContainer
; acquia.wip.handler.containers => \Acquia\WipIntegrations\Container\EcsContainer
acquia.wip.containers => \Acquia\Wip\Implementation\ContainerApi
acquia.wip.dataentrystore => \Acquia\Wip\Implementation\SqliteDataEntryStore
acquia.wip.notification => \Acquia\WipService\Notification\BugsnagNotifier
acquia.wip.signal.signalfactory => \Acquia\Wip\Signal\SignalFactory
acquia.wip.uri.authentication => \Acquia\WipIntegrations\Security\BasicAuthentication
acquia.wip.metrics.relay => \Acquia\WipService\Metrics\HostedGraphiteMetricsRelay singleton
acquia.wip.state_controller => \Acquia\WipService\Runtime\StateController
acquia.wip.pool.controller => \Acquia\Wip\Runtime\WipPoolController singleton
acquia.wipservice.mysql.utility => \Acquia\WipService\MySql\Utility singleton

$acquia.wip.worker.wait.max => 2
$acquia.wip.signal.wip.complete => \Acquia\Wip\Signal\WipCompleteSignal
$acquia.wip.signal.ssh.complete => \Acquia\Wip\Signal\SshCompleteSignal
$acquia.wip.signal.container.complete => \Acquia\Wip\Signal\ContainerCompleteSignal
$acquia.wip.signal.container.terminated => \Acquia\Wip\Signal\ContainerTerminatedSignal
$acquia.wip.signal.container.data => \Acquia\Wip\Signal\ContainerDataSignal
$acquia.wip.signal.acquiacloud.complete => \Acquia\Wip\Signal\AcquiaCloudCompleteSignal
acquia.wip.signal.cleanup => \Acquia\Wip\Signal\CleanupSignal
$acquia.wip.ssl.verifyCertificate => false

; Used by the Cloud API integration to indicate the maximum number of retries
; that should be attempted when a server error occurs during a Cloud API call.
$acquia.wip.acquiacloud.retrycount => 3
$acquia.wip.acquiacloud.retrycodes => [403, 404, 500, 502, 503, 504]

; Used by the runtime statistics functionality to provide a bit of slack for the
; maximum calculated runtime in case systems are overloaded.  This value represents
; the number of seconds to add to the calculated maximum runtime.
$acquia.wip.runtime.maxoffset => 300

; Used by the runtime statistics functionality to override maximum process times
; for particular tasks.  Some tasks have a runtime that depends on the size of a
; database or the number or size of files, so driving maximum run times by
; statistics alone will cause some tasks to fail out erroneously.
; Note this is a comma-separated list of values.
; $acquia.wip.runtime.omittasks =>

; Not very useful in tests, but needs to be set to avoid fatals
$acquia.wip.exec.path => bin/wipctl exec

; Path to the thread pool process's pidfile, used as a mutex lock for processing the thread pool.
$acquia.wip.thread.daemon.pidfile => /tmp/wipthreadpool.pid

; threshold for number of "missed threads" should count as a warning.
$acquia.wip.threadpool.threshold => 50

; Default to executing WIP tasks on servers over SSH (Set this to "local" in
; order to execute WIP tasks locally.  Containers will default to "local".
$acquia.wip.worker_exec_method => ssh

; Sets the variables used by the flushing log store: REST endpoint for POST
; calls; buffer size and log level to trigger flushes; and max number of logs
; per request. Log levels must be valid in WipLogLevel- severity is inversely
; related to the corresponding int value.
$acquia.wip.wipflushinglogstore.endpoint => https://wip-service.local/logs
$acquia.wip.wipflushinglogstore.buffer_size => 20
$acquia.wip.wipflushinglogstore.log_level => 2
$acquia.wip.wipflushinglogstore.max_buffer_size => 100

$acquia.wip.task.run_in_container => false

; By observation the container is still in the PENDING state when the entrypoint
; script starts, and is only moved to the RUNNING state around 5 seconds after
; the start of the entrypoint script. The ENTRY_POINT_DELAY indicates the
; minimum number of seconds the entrypoint script should run before a signal is
; sent to the associated Wip object indicating the container is ready for
; processing.
$acquia.container.entrypoint.delay => 5

; The maximum number of seconds the container will be allowed to execute. This
; value is the limit and may be overridden by a smaller value on a per-workload
; basis.
$acquia.container.maxruntime => 3600

; Indicates whether or not the Wip object should wait for the container to stop
; before exiting. Not waiting allows the Wip object to finish significantly
; faster but fails to  provide an accurate measure of how long each container is
; actually running.
$acquia.container.waitforstop => false

; Indicates whether or not the Wip object should wait for the container to send
; a signal indicating the container is ready. This signal is used when Wip is
; deployed on hosting, but is not used for the DockerContainer.
$acquia.container.waitforstartsignal => true

; Indicates the time, in seconds, that should be waited between calls to check
; for tasks that are still processing.
$acquia.wipctl.pause.sleeptime => 5

; Indicates the maximum number of Wip tasks per server thread that can be in
; progress at any given point. This is effectively a knob that we can turn to
; increase the number of Wip objects that run simultaneously without having to
; add new hardware or increase the hardware size.
;
; There is a limit at which the throughput falls off because there are not
; enough server processes to service all of the Wip tasks as their asynchronous
; work completes.
$acquia.wip.threadpool.max_tasks_per_thread => 4

; The name of the directory containing Wip Modules.
$wip.modules.directory => modules

; Add a delay when not running test.
$acquia.pipeline.client.retry_delay => 5000

; Indicates the maximum time allowed during a build in which no output is
; written. After this duration the build will stop.
$acquia.pipeline.buildsteps.max_build_idle_time => 600

; When the system is paused, database use is reduced to a minimum. This value
; indicates the frequency, expressed in seconds, between database queries to
; determine whether the system has been resumed.
$acquia.wip.threadpool.resume_delay => 5

; When there are no tasks to process, database use is reduced. This value
; indicates the frequency, expressed in seconds, between database queries to
; fetch tasks again after the first fetch resulted in no tasks.
$acquia.wip.threadpool.no_task_delay => 5

; Whether ThreadPoolProcessDetail should be logging.
$acquia.wip.process.details.logging => FALSE
; Whether the logging should be verbose.
$acquia.wip.process.details.verbose => FALSE

; Enables the simulation of dispatch failures. These failures can occur if a
; process exits unexpectedly for any reason; this mechanism is used to validate
; the error detection and cleanup behavior for these errors that can be very
; difficult to reproduce in all of the right places without force. The value is
; expressed as a percentage and identifies the failure frequency. On production
; this must always be 0, and we will use the debug flag to help ensure that.
$acquia.wip.dispatch.simulate.failure => 0

; Enables the simulation of lost dispatch completion signals. These signals are
; received when the process representing a dispatched task completes and hold
; information that can be used to determine whether the dispatch was completed,
; where the dispatch failed, whether the task and thread can be fixed, and how
; to fix them. The value is expressed as a percentage and identifies the failure
; frequency. On production this must always be 0, and we will use the debug flag
; to help ensure that.
$acquia.wip.signal.simulate.failure => 0

; Identifies the policy used if a task is executed but the resulting object is
; not saved. This can be the result of a fatal error that aborts task processing
; after task processing has begun. Aborting on this condition guarantees that
; the task's states do not get executed more than once. Not aborting prevents
; the task from failing by always cleaning up the task and thread, and not
; aborting can result in a state being executed multiple times.
$acquia.wip.dispatch.abort_on_failure => TRUE

; The time threshold after which a task in PROCESSING state or a thread in the
; RUNNING state will be considered "interesting" and a potential candidate for
; cleanup. This situation is normal when the task is currently being processed.
; If anything should happen such that the task and thread are not cleaned up
; through the normal process, the system will eventually notice that and verify
; that the thread is still "live" by verifying that the associated process is
; indeed still running. If the process is no longer running, the thread and task
; will be cleaned up. This threshold limits the system from checking for these
; inconsistencies until a reasonable amount of time has passed to prevent
; unnecessary load.
$acquia.wip.database.cleanup.threshold => 120

; @see $acquia.wip.database.cleanup.threshold for an explanation of how the
; system determines a thread is no longer running. This value represents the
; maximum duration a task can be in the PROCESSING state without the system
; failing it out. This forced failure prevents a task from remaining in an
; infinite loop.
$acquia.wip.database.cleanup.fail => 300

; The number of seconds to wait for an SshCompleteSignal before attempting to
; grab the process result from the server directly. Generally when an
; asynchronous SSH call is made, there is no need to check for the result
; because a signal that contains the result is received. It is possible that the
; process sent a signal, but before that signal was acknowledged by the task,
; the task discovers the process is no longer running and will check the server
; for the result. This value is used in this case to delay asking the server
; for the result until a reasonable amount of time has passed during which the
; signal should be received by the task.
$acquia.wip.ssh.signal.wait => 15

; If the signal from an asynchronous SSH command is not received after the
; process ends and the result cannot be retrieved from the server, the
; asynchronous process will report a failure instead of the SSH result. This
; threshold represents the number of seconds to wait for the SSH result to be
; available before the process is considered to have failed.
$acquia.wip.ssh.result.timeout => 120

; Whether or not to log debug messages about the duration of certain command
; executions, initially WipExecCommand and WipRecoverCommand.
$acquia.command.duration.logs => FALSE
